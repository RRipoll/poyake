package com.etantolling.testrunner.test.core.utils;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;

/**
 * This class is an utility for loading into a database for further analysis 
 * the content of the jdbc.log generated by the p6spy tool.
 * 
 * @see http://idcjira.cloudapp.net/confluence/display/NH/Database+notes+for+developers#Databasenotesfordevelopers-SQLQueriestracing
 */
public class JdbcLogFileLoader {
	
	private static final String SYNOPSYS = "Synopsys: JdbcLogFileLoader jdbc.log environment_name test_number";
	private static final String SQL = "INSERT INTO ADM_SQL_LOG VALUES(?,?,?,?,?,?,?,?,?)";
	private static final String SEP = "|"; // Separator
	
	public static void main(String[] args) throws Throwable {
		if (args.length!=3) {
			System.out.println("Invalid number of parameters\n"+SYNOPSYS);
		} else {
			try (Connection conn = getConnection()) {
				loadJdbcLog(conn,args[0], args[1], args[2]);
			}
		}
	}

	private static void loadJdbcLog(Connection conn, String fullPath, String envName, String test) throws Exception {
		int start = 0;
		int end = 0;
		int lines = 0;
		String line = null;
		long time = System.currentTimeMillis();
		try (
				PreparedStatement pstmt = conn.prepareStatement(SQL);
				BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(fullPath)));
			) {
			conn.setAutoCommit(false);
			while ((line = reader.readLine()) != null) {
				System.out.println(line);
				if (!line.trim().isEmpty()) {
					start = end = 0;
					lines++;
					pstmt.setString(1, envName);
					pstmt.setString(2, test);
					// Unfortunately, we cannot use String.split("|") because the || used by Oracle for concats
					end = line.indexOf(SEP, start);
					pstmt.setTimestamp(3, new Timestamp(Long.parseLong(line.substring(start,end)))); // date time
					start = end + 1;
					end = line.indexOf(SEP,start);
					pstmt.setInt(4, Integer.parseInt(line.substring(start,end))); // elapsed time
					start = end + 1;
					end = line.indexOf(SEP,start);
					pstmt.setString(5, line.substring(start,end)); // query type
					start = end + 1;
					end = line.indexOf(SEP,start);
					pstmt.setString(6, line.substring(start,end)); // connection id
					start = end + 1;
					end = line.indexOf(SEP,start);
					// in the prepared statement we have first to check if there is any || in the sql 
					while (end+1 < line.length() && line.charAt(end+1) == '|') {
						end = line.indexOf(SEP,end+2);// we skip the 2 characters || and look for the next |
					}
					String prepStmtColumn = line.substring(start,end);
					pstmt.setInt(7, generateHash(prepStmtColumn));
					pstmt.setString(8, prepStmtColumn); // PreparedStatement
					// last column can be empty if no prepared statement column in the jdbc.log for this sentence
					if (end + 1 == line.length()) {
						// there is no more columns, we use same substring in preparedStatement column and statement executed column
						pstmt.setString(9, line.substring(start,end)); // executed statement
					} else {
						pstmt.setString(9, line.substring(end, line.length())); // executed statement
					}
					pstmt.addBatch();
					if (lines%1000==0) {
						// Execute batches of 100 sentences
						pstmt.executeBatch();
						conn.commit();
					}
				}
			}
			pstmt.executeBatch();
			conn.commit();
			System.out.println("Total " + lines + " loaded in " + (System.currentTimeMillis() - time ) + "ms" );
		}
	}

	private static Connection getConnection() throws SQLException {
		// We use JDBC 4.0 Oracle Driver, so we do not need to do the Class.forName anymore
		Connection conn =  DriverManager.getConnection ("jdbc:oracle:thin:@localhost:1521:nhdevdb",
				       "TESTREPOSITORY", "IDeeSee");
		return conn;
	}
	
	private static int generateHash(String str) {
		int hash = 7;
		int strlen = str.length();
		for (int i = 0; i < strlen; i++) {
		    hash = hash*31 + str.charAt(i);
		}
		return hash;
	}
}